fakeInlineCache
"
The real inline cache (see #inlineCaches) is not yet implemented.  In the meantime a far simpler, low-performance alternative is being used (mainly to investigate the GC behaviour in the presences of inline caches) in the form of the Fake Inline Cache.

There are no distinct opcodes for linked and unlinked sends.  Each send opcode must guarantee one thing: that the literal index of the selector is placed in the *last* extension word of the opcode.  (localIP therefore points at this location at the moment the send is actually invoked.)  This word is fetched into some temporary variable (let's call it 'selOrMeth' for now) and argumentCount is set appropriately before invoking the send mechanism.

The send mechanism checks selOrMeth.  If this is an integer object then the send is 'unlinked' and it contains the literal frame index of the message selector, otherwise the send is 'linked' and selOrMeth contains the destination TranslatedMethod.

For unlinked sends, the messageSelector is fetched from the literal frame.  If the selector is #doesNotUnderstand: then a normal send is performed without attempting to link the destination method.  (Linking the send in this case would be disasterous: the argumentCount would most likely be wrong, and the expected Message object would not be present on the stack.)  If the selector is something else then the class of the receiver is fetched, #findNewMethodInClass: is invoked to find the destination newTranslatedMethod, and this value is written into the location pointed to by localIP -- thus replacing the selector index in the caller's translated method.  The MethodClass field of the translated method is initialised appropriately (with the class of the receiver) along with various other interpreter registers (primIndex, newMethod and messageSelector), and finally the method is executed as normal.

For linked sends, the class of the receiver is fetched and compared against the MethodClass field in the cached translated method.  If they agree, the interpeter restores the interpreter state cached in the destination method (messageSelector, method, primitiveIndex) and then executes the method directly, without performing any lookup.  If the receiver's class does not agree with that stored in the translated method's header, the send is relinked by setting messageSelector to the value stored in the method header and performing the linking steps described above.  Note that once a send site has been successfully linked, the semantics of the language guarantee that the argumentCount and messageSelector at that send site never change.

The main purpose of the Fake Inline Cache is to provide a trivial mechanism that can be used to instrument the interpreter's behaviour when inline caches are in use, and to investigate management algorithms and heuristics that will eventually influence the implementation details of the real inline cache.  In short: the performance sucks.
"
	^self error: 'documentation only'